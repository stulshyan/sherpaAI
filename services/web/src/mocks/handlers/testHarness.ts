import { delay, http, HttpResponse } from 'msw';

// In-memory test configuration (mirrors backend)
interface TestConfig {
  adapterId: string;
  temperature: number;
  maxTokens: number;
  simulateFailure: boolean;
  simulateLatencyMs: number;
}

let testConfig: TestConfig = {
  adapterId: 'anthropic-claude-4-sonnet',
  temperature: 0.7,
  maxTokens: 1024,
  simulateFailure: false,
  simulateLatencyMs: 0,
};

// Mock adapter list
const mockAdapters = [
  { id: 'anthropic-claude-4-sonnet', provider: 'anthropic', model: 'claude-sonnet-4-5-20250929' },
  { id: 'anthropic-claude-4-opus', provider: 'anthropic', model: 'claude-opus-4-5-20251101' },
  { id: 'openai-gpt-4o', provider: 'openai', model: 'gpt-4o' },
  { id: 'google-gemini-pro', provider: 'google', model: 'gemini-1.5-pro' },
];

// Mock responses for different prompts
function generateMockResponse(prompt: string): string {
  const lowerPrompt = prompt.toLowerCase();

  if (lowerPrompt.includes('hello') || lowerPrompt.includes('hi')) {
    return "Hello! I'm a mock AI assistant running in development mode. How can I help you today?";
  }

  if (lowerPrompt.includes('test')) {
    return 'This is a test response from the mock adapter. The test harness is working correctly in development mode.';
  }

  if (lowerPrompt.includes('code') || lowerPrompt.includes('function')) {
    return `Here's a sample code snippet:

\`\`\`typescript
function greet(name: string): string {
  return \`Hello, \${name}!\`;
}

console.log(greet('World'));
\`\`\`

This is a mock response - in production, this would be generated by the actual AI model.`;
  }

  return `I received your prompt: "${prompt.substring(0, 50)}${prompt.length > 50 ? '...' : ''}"

This is a **mock response** generated by MSW (Mock Service Worker) for development testing. In production, this endpoint connects to real AI model providers (Anthropic, OpenAI, Google).

The test harness is working correctly!`;
}

export const testHarnessHandlers = [
  // GET /api/v1/test-harness/config - Get current configuration
  http.get('/api/v1/test-harness/config', async () => {
    await delay(100);
    return HttpResponse.json(testConfig);
  }),

  // PATCH /api/v1/test-harness/config - Update configuration
  http.patch('/api/v1/test-harness/config', async ({ request }) => {
    await delay(100);
    const updates = (await request.json()) as Partial<TestConfig>;

    // Validate adapterId if provided
    if (updates.adapterId) {
      const validAdapter = mockAdapters.find((a) => a.id === updates.adapterId);
      if (!validAdapter) {
        return HttpResponse.json(
          {
            error: `Invalid adapter ID: ${updates.adapterId}`,
            availableAdapters: mockAdapters.map((a) => a.id),
          },
          { status: 400 }
        );
      }
    }

    testConfig = { ...testConfig, ...updates };
    return HttpResponse.json({ success: true, config: testConfig });
  }),

  // GET /api/v1/test-harness/adapters - List available adapters
  http.get('/api/v1/test-harness/adapters', async () => {
    await delay(100);
    return HttpResponse.json({
      adapters: mockAdapters,
      defaultAdapterId: testConfig.adapterId,
    });
  }),

  // POST /api/v1/test-harness/complete - Test completion
  http.post('/api/v1/test-harness/complete', async ({ request }) => {
    const body = (await request.json()) as { prompt: string; systemPrompt?: string };

    if (!body.prompt || typeof body.prompt !== 'string') {
      return HttpResponse.json({ error: 'prompt is required' }, { status: 400 });
    }

    // Simulate configured latency
    const baseLatency = 200 + Math.random() * 300; // 200-500ms base
    await delay(testConfig.simulateLatencyMs + baseLatency);

    // Simulate failure if enabled
    if (testConfig.simulateFailure) {
      return HttpResponse.json(
        {
          error: 'Simulated API failure',
          simulatedFailure: true,
          message: 'This failure was intentionally triggered for testing',
        },
        { status: 503 }
      );
    }

    const mockContent = generateMockResponse(body.prompt);
    const inputTokens = Math.ceil(body.prompt.length / 4);
    const outputTokens = Math.ceil(mockContent.length / 4);

    // Get current adapter info
    const currentAdapter = mockAdapters.find((a) => a.id === testConfig.adapterId);

    return HttpResponse.json({
      content: mockContent,
      model: currentAdapter?.model || 'claude-sonnet-4-5-20250929',
      finishReason: 'end_turn',
      requestId: `mock-${Date.now()}-${Math.random().toString(36).substring(7)}`,
      metrics: {
        latencyMs: Math.round(baseLatency),
        tokensIn: inputTokens,
        tokensOut: outputTokens,
        totalTokens: inputTokens + outputTokens,
        costUsd: (inputTokens * 0.003 + outputTokens * 0.015) / 1000,
      },
      config: {
        adapterId: testConfig.adapterId,
        temperature: testConfig.temperature,
        maxTokens: testConfig.maxTokens,
      },
    });
  }),

  // POST /api/v1/test-harness/health - Health check
  http.post('/api/v1/test-harness/health', async ({ request }) => {
    await delay(300);
    const body = (await request.json()) as { adapterId?: string };

    if (body.adapterId) {
      // Check specific adapter
      const validAdapter = mockAdapters.find((a) => a.id === body.adapterId);
      if (!validAdapter) {
        return HttpResponse.json({ error: `Unknown adapter: ${body.adapterId}` }, { status: 400 });
      }
      return HttpResponse.json({ adapterId: body.adapterId, healthy: true });
    } else {
      // Check all adapters
      const healthStatus: Record<string, boolean> = {};
      mockAdapters.forEach((adapter) => {
        healthStatus[adapter.id] = true;
      });
      return HttpResponse.json({ adapters: healthStatus });
    }
  }),

  // POST /api/v1/test-harness/count-tokens - Count tokens
  http.post('/api/v1/test-harness/count-tokens', async ({ request }) => {
    await delay(50);
    const body = (await request.json()) as { text: string };

    if (!body.text || typeof body.text !== 'string') {
      return HttpResponse.json({ error: 'text is required' }, { status: 400 });
    }

    // Approximate token count (roughly 4 chars per token)
    const tokenCount = Math.ceil(body.text.length / 4);

    return HttpResponse.json({
      text: body.text.substring(0, 100) + (body.text.length > 100 ? '...' : ''),
      tokenCount,
      adapterId: testConfig.adapterId,
    });
  }),

  // POST /api/v1/test-harness/estimate-cost - Estimate cost
  http.post('/api/v1/test-harness/estimate-cost', async ({ request }) => {
    await delay(50);
    const body = (await request.json()) as { inputTokens: number; outputTokens: number };

    if (typeof body.inputTokens !== 'number' || typeof body.outputTokens !== 'number') {
      return HttpResponse.json(
        { error: 'inputTokens and outputTokens are required' },
        { status: 400 }
      );
    }

    const usage = {
      inputTokens: body.inputTokens,
      outputTokens: body.outputTokens,
      totalTokens: body.inputTokens + body.outputTokens,
    };

    // Mock cost calculation (Claude Sonnet pricing)
    const costUsd = (body.inputTokens * 0.003 + body.outputTokens * 0.015) / 1000;

    return HttpResponse.json({
      usage,
      costUsd,
      adapterId: testConfig.adapterId,
    });
  }),
];
